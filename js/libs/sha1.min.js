"use strict";const sha1=(()=>{const logic=(()=>{const H=[0x67452301,0xefcdab89,0x98badcfe,0x10325476,0xc3d2e1f0];const K=[0x5a827999,0x6ed9eba1,0x8f1bbcdc,0xca62c1d6];const transform=(registers,slice,length)=>{if(slice.length===64)return compress(registers,convert(slice));else if(slice.length>=56)return compress(compress(registers,convert(pad(slice))),append(convert(pad([],0)),length));else return compress(registers,append(convert(pad(slice)),length));};const pad=(slice,first=0x80)=>{slice[slice.length]=first;for(let i=slice.length;i<64;i++)slice[i]=0;return slice;};const convert=slice=>{let retval=new Uint32Array(slice.length/4);for(let i=0;i<retval.length;i++)retval[i]=(slice[i*4]<<24)|(slice[i*4+1]<<16)|(slice[i*4+2]<<8)|slice[i*4+3];return retval;};const append=(chunk,length)=>{const hex=(length*8).toString(16).padStart(16,"0");chunk[chunk.length-2]=parseInt(hex.substring(0,8),16);chunk[chunk.length-1]=parseInt(hex.substring(8,16),16);return chunk;};const compress=(registers,chunk)=>{const w=init(chunk);let r=new Uint32Array(registers);for(let i=0;i<80;i++){let f;if(i<20)f=(r[1]&r[2])|((~r[1])&r[3]);else if(i>=40&&i<60)f=(r[1]&r[2])|(r[1]&r[3])|(r[2]&r[3]);else f=r[1]^r[2]^r[3];const temp=rotl(r[0],5)+f+r[4]+K[(i/20)&0xff]+w[i];r[4]=r[3];r[3]=r[2];r[2]=rotl(r[1],30);r[1]=r[0];r[0]=temp;}for(let i=0;i<r.length;i++)r[i]+=registers[i];return r;};const init=chunk=>{let retval=new Uint32Array(80);for(let i=0;i<80;i++){if(i<16)retval[i]=chunk[i];else retval[i]=rotl(retval[i-3]^retval[i-8]^retval[i-14]^retval[i-16],1);}return retval;};const serialize=registers=>{let retval=[];for(let i=0;i<registers.length;i++){retval[i*4]=(registers[i]>>>24)&0xff;retval[i*4+1]=(registers[i]>>>16)&0xff;retval[i*4+2]=(registers[i]>>>8)&0xff;retval[i*4+3]=registers[i]&0xff;}return retval;};const rotl=(n,i)=>(n<<i)|(n>>>(32-i));return{process(data){const bytes=conversion.to_byte(data);let registers=new Uint32Array(H);for(let i=0;i<=bytes.length;i+=64)registers=transform(registers,bytes.slice(i,i+64),bytes.length);return serialize(registers);}}})();const conversion=(()=>{return{to_byte(data){const type=Object.prototype.toString.call(data);switch(type){case"[object Array]":return data.slice();case"[object String]":return[].slice.call(new TextEncoder().encode(data));case"[object Uint8Array]":return[].slice.call(data);case"[object ArrayBuffer]":return[].slice.call(new Uint8Array(data));default:throw new Error(`Invalid data type "${type}" provided.`);}},to_hex(arr){return arr.map(x=>x.toString(16).padStart(2,'0')).join('');},to_base64(arr){return btoa(arr.map(x=>String.fromCharCode(x)).join(''));}}})();const hash=(()=>{return{array(data){return logic.process(data);},hex(data){return conversion.to_hex(this.array(data));},base64(data){return conversion.to_base64(this.array(data));}}})();return{hash:hash}})();